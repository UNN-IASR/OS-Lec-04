<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>Лекция 4. Общие сведения о файловых системах</title>
<meta http-equiv="Content-Language" content="English" />
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
<link rel="stylesheet" type="text/css" href="style.css" media="screen" />
</head>
<body>

<div id="wrap">
<div id="header">
<h1><a href="#">Лекция 4. Общие сведения о файловых системах</a></h1></div>
<div id="menu"></div>
<div id="content">
<div class="left">
<h2>1 Понятие файловой системы</h2>
<a name="1-1-Понятие файловой системы"></a>
<h4>Файловая система</h4><a name="3-100-Файловая система"></a>
<p><i>Файловая система</i> - это часть операционной системы, назначение которой состоит в том, чтобы организовать эффективную работу с данными, хранящимися во внешней памяти, и обеспечить пользователю удобный интерфейс при работе с такими данными.
</p><br>

<p>Файловая система представляет собой абстрактный слой для предоставления пользователю удобного доступа к данным и выполнения им действий с этими данными.
</p><br>

<p>Центральным понятием ФС является файл, представляющий собой некоторую поименованную совокупность данных. С точки зрения пользователя файл представляет собой хранилище однородной информации. Например, файлы делят на текстовые, графические, звуковые и т.д.
</p><p>С точки зрения операционной системы, <i>файл</i>  - это набор связанных блоков (кластеров), образующих цепочку (списокa). 
</p><br>

<p>Файловая система позволяет при помощи системы справочников (каталогов, директорий) связать уникальное имя файла с блоками вторичной памяти, содержащими данные файла. 
</p><br>

<p>Иерархическая структура каталогов, используемая для управления файлами, может служить другим примером индексной структуры. В этом случае каталоги или папки играют роль индексов, каждый из которых содержит ссылки на свои подкаталоги. С этой точки зрения вся файловая система компьютера представляет собой большой индексированный файл. Помимо собственно файлов и структур данных, используемых для управления файлами (каталоги, дескрипторы файлов, различные таблицы распределения внешней памяти), понятие "файловая система" включает программные средства, реализующие различные операции над файлами.
</p><h4>Функции файловой системы</h4><a name="3-120-Функции файловой системы"></a>
<ol>
<li> <b>Идентификация файлов</b>. Связывание имени файла с выделенным ему пространством внешней памяти.
<li> <b>Распределение внешней памяти между файлами</b>. Для работы с конкретным файлом пользователю не требуется иметь информацию о местоположении этого файла на внешнем носителе информации. Например, для того чтобы загрузить документ в редактор с жесткого диска, нам не нужно знать, на какой стороне какого магнитного диска, на каком цилиндре и в каком секторе находится данный документ.
<li> <b>Обеспечение надежности и отказоустойчивости</b>. Стоимость информации может во много раз превышать стоимость компьютера.
<li> <b>Обеспечение защиты</b> от несанкционированного доступа.
<li> <b>Обеспечение совместного доступа к файлам</b>, так чтобы пользователю не приходилось прилагать специальных усилий по обеспечению синхронизации доступа.
<li> <b>Обеспечение высокой производительности</b>
</ol>
<h2>2 Общие сведения о файлах</h2>
<a name="1-2-Общие сведения о файлах"></a>
<h3>2.1 Имена файлов</h3>
<a name="2-3-Имена файлов"></a>
<p><i>Файлы</i> представляют собой абстрактные объекты. Их задача - хранить информацию, скрывая от пользователя детали работы с устройствами. Когда процесс создает файл, он дает ему имя. После завершения процесса файл продолжает существовать и через свое имя может быть доступен другим процессам.
</p><br>

<p>Правила именования файлов зависят от ОС. Многие ОС поддерживают имена из двух частей <i>(имя+расширение)</i>, например <b>progr.c</b> (файл, содержащий текст программы на языке Си) или <b>autoexec.bat</b> (файл, содержащий команды интерпретатора командного языка). 
</p><p>Тип расширения файла позволяет ОС организовать работу с ним различных прикладных программ в соответствии с заранее оговоренными соглашениями. Обычно ОС накладывают некоторые ограничения, как на используемые в имени символы, так и на длину имени файла. В соответствии со стандартом POSIX, популярные ОС оперируют удобными для пользователя длинными именами (до 255 символов).
</p><h3>2.2 Типы файлов</h3>
<a name="2-4-Типы файлов"></a>
<p>Основные <b>типы файлов</b>: 
</p><ol>
<li> <b>регулярные</b> (обычные) файлы
<li> <b>директории</b> (справочники, каталоги). 
<li> <b>специальные файлы</b> (устройства, ссылки в UNIX).
</ol>
<p>Обычные файлы содержат пользовательскую информацию. Директории - системные файлы, поддерживающие структуру файловой системы. В каталоге содержится перечень входящих в него файлов и устанавливается соответствие между файлами и их характеристиками (атрибутами). .
</p><p>Хотя внутри подсистемы управления файлами обычный <b>файл</b> представляется в виде набора блоков внешней памяти, для пользователей обеспечивается представление файла в виде линейной последовательности байтов. 
</p><br>

<p>Такое представление позволяет использовать абстракцию файла при работе с внешними устройствами, при организации межпроцессных взаимодействий и т. д. 
</p><br>

<p>Так, например, <b>клавиатура</b> обычно рассматривается как текстовый файл, из которого компьютер получает данные в символьном формате. Поэтому иногда к файлам приписывают другие объекты ОС, например специальные символьные файлы и специальные блочные файлы, именованные каналы и сокеты, имеющие файловый интерфейс.
</p><p><b>Обычные</b> (или регулярные) файлы реально представляют собой набор блоков (возможно, пустой) на устройстве внешней памяти, на котором поддерживается файловая система. Такие файлы могут содержать как текстовую информацию (обычно в формате ASCII), так и произвольную двоичную (бинарную) информацию.
</p><br>

<p><b>Текстовые</b> файлы содержат символьные строки, которые можно распечатать, увидеть на экране или редактировать обычным текстовым редактором.
</p><br>

<p>Другой тип файлов - нетекстовые, или <b>бинарные</b>, файлы. Обычно они имеют некоторую внутреннюю структуру. Например, исполняемый файл в ОС Unix имеет пять секций: заголовок, текст, данные, биты реаллокации и символьную таблицу. ОС выполняет файл, только если он имеет нужный формат. Другим примером бинарного файла может быть архивный файл. Типизация файлов не слишком строгая.
</p><p>Обычно прикладные программы, работающие с файлами, распознают тип файла по его имени в соответствии с общепринятыми соглашениями. Например, файлы с расширениями <b>.c, .pas, .txt</b> - ASCII-файлы, файлы с расширениями <b>.exe</b> - выполнимые, файлы с расширениями <b>.obj</b>, <b>.zip</b> - бинарные и т. д. 
</p><h3>2.3 Атрибуты файлов</h3>
<a name="2-5-Атрибуты файлов"></a>
<p>Кроме имени ОС часто связывают с каждым файлом и другую информацию, например дату модификации, размер и т. д. Эти другие характеристики файлов называются <i>атрибутами</i>. 
</p><br>

<p>Список атрибутов в разных ОС может варьироваться. Обычно он содержит следующие элементы: 
</p><ul>
<li> основную информацию (имя, тип файла), 
<li> адресную информацию (устройство, начальный адрес, размер), 
<li> информацию об управлении доступом (владелец, допустимые операции) 
<li> информацию об использовании (даты создания, последнего чтения, модификации и др.).
</ul>
<p>Список атрибутов обычно хранится в структуре директорий или других структурах, обеспечивающих доступ к данным файла.
</p><h3>2.4 Операции над файлами</h3>
<a name="2-6-Операции над файлами"></a>
<p>При разрабоке прогрммы, программист может использовать следующие операции:
</p><ul>
<li> <b>Создание файла</b>, не содержащего данных. Смысл данного вызова - объявить, что файл существует, и присвоить ему ряд атрибутов. При этом выделяется место для файла на диске и вносится запись в каталог.
<li> <b>Удаление файла</b> и освобождение занимаемого им дискового пространства.
<li> <b>Открытие файла</b>. Перед использованием файла процесс должен его открыть. Цель данного системного вызова - разрешить системе проанализировать атрибуты файла и проверить права доступа к нему, а также считать в оперативную память список адресов блоков файла для быстрого доступа к его данным. Открытие файла является процедурой создания дескриптора или управляющего блока файла. Дескриптор (описатель) файла хранит всю информацию о нем. Иногда, в соответствии с парадигмой, принятой в языках программирования, под дескриптором понимается альтернативное имя файла или указатель на описание файла в таблице открытых файлов, используемый при последующей работе с файлом . Например, на языке Cи операция открытия файла fd=open(pathname,flags,modes); возвращает дескриптор fd, который может быть задействован при выполнении операций чтения (read(fd,buffer,count); ) или записи. 
</ul>
<ul>
<li> <b>Закрытие файла</b>. Если работа с файлом завершена, его атрибуты и адреса блоков на диске больше не нужны. В этом случае файл нужно закрыть, чтобы освободить место во внутренних таблицах файловой системы.
<li> <b>Позиционирование</b>. Дает возможность специфицировать место внутри файла, откуда будет производиться считывание (или запись) данных, то есть задать текущую позицию.
<li> <b>Чтение данных из файла</b>. Обычно это делается с текущей позиции. Пользователь должен задать объем считываемых данных и предоставить для них буфер в оперативной памяти.
<li> <b>Запись данных в файл</b> с текущей позиции. Если текущая позиция находится в конце файла, его размер увеличивается, в противном случае запись осуществляется на место имеющихся данных, которые, таким образом, теряются. 
</ul>
<h2>3 Директории(папки)</h2>
<a name="1-7-Директории(папки)"></a>
<h3>3.1 Общие сведения о директориях</h3>
<a name="2-8-Общие сведения о директориях"></a>
<h4>Директории</h4><a name="3-400-Директории"></a>
<p>Количество файлов на компьютере может быть большим. Отдельные системы хранят тысячи файлов, занимающие сотни гигабайтов дискового пространства. Эффективное управление этими данными подразумевает наличие в них четкой логической структуры. Все современные файловые системы поддерживают многоуровневое именование файлов за счет наличия во внешней памяти дополнительных файлов со специальной структурой - <i>каталогов</i> (или директорий).
</p><br>

<p>Каждый каталог содержит список каталогов и/или файлов, содержащихся в данном каталоге. Каталоги имеют один и тот же внутренний формат, где каждому файлу соответствует одна запись в файле директории.
</p><br>

<p>Число директорий зависит от системы. В ранних ОС имелась только одна корневая директория, затем появились директории для пользователей (по одной директории на пользователя). В современных ОС используется произвольная структура дерева директорий. 
</p><p>Таким образом, файлы на диске образуют иерархическую древовидную структуру:
</p><br>



<img src='tree.png'>

<p>Существует несколько эквивалентных способов изображения дерева. Структура перевернутого дерева, приведенного на рисунке, наиболее распространена. Верхнюю вершину называют <b>корнем</b>. Если элемент дерева не может иметь потомков, он называется терминальной вершиной или <b>листом</b> (в данном случае является <b>файлом</b>). Нелистовые вершины - справочники или каталоги содержат списки листовых и нелистовых вершин. <b>Путь</b> от корня к файлу однозначно определяет файл.
</p><br>

<p>Внутри одного каталога имена листовых файлов уникальны. Имена файлов, находящихся в разных каталогах, могут совпадать. Для того чтобы однозначно определить файл по его имени (избежать коллизии имен), принято именовать файл так называемым <b>абсолютным</b> или полным именем <b>(pathname)</b>, состоящим из списка имен вложенных каталогов, по которому можно найти путь от корня к файлу плюс имя файла в каталоге, непосредственно содержащем данный файл. 
</p><p>Полное имя включает цепочку имен - путь к файлу, например 
</p><pre>
<p>/usr/games/doom 
</p></pre>
<p>Такие имена уникальны. Компоненты пути разделяют различными символами: "/" (слэш) в Unix или обратными слэшем в MS-DOS (в Multics - ">"). Таким образом, использование древовидных каталогов минимизирует сложность назначения уникальных имен.
</p><br>

<p>Указывать полное имя не всегда удобно, поэтому применяют другой способ задания имени - <b>относительный</b> путь к файлу. Он использует концепцию рабочей или текущей директории, которая обычно входит в состав атрибутов процесса, работающего с данным файлом. Тогда на файлы в такой директории можно ссылаться только по имени, при этом поиск файла будет осуществляться в рабочем каталоге. Это удобнее, но, по существу, то же самое, что и абсолютная форма.
</p><p>Для получения доступа к файлу и локализации его блоков система должна выполнить навигацию по каталогам. 
</p><br>

<p>Рассмотрим для примера путь <b>/usr/linux/progr.c</b>. Алгоритм одинаков для всех иерархических систем. 
</p><ol>
<li> В фиксированном месте на диске находится корневая директория
<li> Находится компонент пути <b>usr</b>, т. е. в корневой директории ищется файл <b>/usr</b>. 
<li> Исследуя этот файл, система понимает, что данный файл является каталогом, и блоки его данных рассматривает как список файлов и ищет следующий компонент <b>linux</b> в нем. 
<li> Из строки для <b>linux</b> находится файл, соответствующий компоненту <b>usr/linux/</b>. 
<li> Затем находится компонент <b>progr.c</b>, который открывается, заносится в таблицу открытых файлов и сохраняется в ней до закрытия файла.
</ol>
<p>Многие прикладные программы работают с файлами, находящимися в текущей директории, не указывая явным образом ее имени. Это дает пользователю возможность произвольным образом именовать каталоги, содержащие различные программные пакеты. Для реализации этой возможности в большинстве ОС, поддерживающих иерархическую структуру директорий, используется обозначение "." - для текущей директории и ".." - для родительской.
</p><h3>3.2 Разделы и имена файлов</h3>
<a name="2-9-Разделы и имена файлов"></a>
<p>В некоторых системах управления файлами требуется, чтобы каждый архив файлов целиком располагался на одном диске (разделе диска). В этом случае полное имя файла начинается с имени дискового устройства, на котором установлен соответствующий диск (буквы диска). Например, <b>c:\util\nu\ndd.exe</b>. Такой способ именования используется в файловых системах DEC и Microsoft.
</p><p>В ОС Unix предполагается наличие нескольких архивов файлов, каждый на своем разделе, один из которых считается корневым. После запуска системы можно "смонтировать" корневую файловую систему и ряд изолированных файловых систем в одну общую файловую систему.
</p><p>Технически это осуществляется с помощью создания в корневой файловой системе специальных пустых каталогов. Специальный системный вызов <b>mount</b> ОС Unix позволяет подключить к одному из этих пустых каталогов корневой каталог указанного архива файлов. После монтирования общей файловой системы именование файлов производится так же, как если бы она с самого начала была централизованной. Задачей ОС является беспрепятственный проход точки монтирования при получении доступа к файлу по цепочке имен. Если учесть, что обычно монтирование файловой системы производится при загрузке системы, пользователи ОС Unix обычно и не задумываются о происхождении общей файловой системы.
</p><h3>3.3 Операции над директориями</h3>
<a name="2-10-Операции над директориями"></a>
<p>Перечислим основные операции над директориями, которые ожет использовть прораммист ри разработке программы:
</p><ul>
<li> <b>Создание директории</b>. Вновь созданная директория включает записи с именами '.' и '..', однако считается пустой.
<li> <b>Удаление директории</b>. Удалена может быть только пустая директория.
<li> <b>Открытие директории</b> для последующего чтения. Hапример, чтобы перечислить файлы, входящие в директорию, процесс должен открыть директорию и считать имена всех файлов, которые она включает.
<li> <b>Закрытие директории</b> после ее чтения для освобождения места во внутренних системных таблицах.
<li> <b>Поиск</b>. Данный системный вызов возвращает содержимое текущей записи в открытой директории. Вообще говоря, для этих целей может использоваться системный вызов Read, но в этом случае от программиста потребуется знание внутренней структуры директории. 
</ul>
<ul>
<li> <b>Получение списка файлов</b> в каталоге.
<li> <b>Переименование</b>. Имена директорий можно менять, как и имена файлов.
<li> <b>Создание файла</b>. При создании нового файла необходимо добавить в каталог соответствующий элемент.
<li> <b>Удаление файла</b>. Удаление из каталога соответствующего элемента. Если удаляемый файл присутствует только в одной директории, то он вообще удаляется из файловой системы, в противном случае система ограничивается только удалением специфицируемой записи.
</ul>
<h2>4 Защита файлов и директорий</h2>
<a name="1-11-Защита файлов и директорий"></a>
<h4>Права доступа</h4><a name="3-560-Права доступа"></a>
<p>Наличие в системе многих пользователей предполагает организацию контролируемого доступа к файлам. Выполнение любой операции над файлом должно быть разрешено только в случае наличия у пользователя соответствующих привилегий. 
</p><br>

<p>Обычно контролируются следующие операции: <b>чтение</b>, <b>запись</b> и <b>выполнение</b>. Другие операции, например копирование файлов или их переименование, также могут контролироваться. Однако они чаще реализуются через перечисленные. Так, операцию копирования файлов можно представить как операцию чтения и последующую операцию записи.
</p><p>Hаиболее общий подход к защите файлов от несанкционированного использования - сделать доступ зависящим от идентификатора пользователя, то есть связать с каждым файлом или директорией <i>список прав доступа (access control list)</i>, где перечислены имена пользователей и типы разрешенных для них способов доступа к файлу.
</p><br>

<p>Любой запрос на выполнение операции сверяется с таким списком. Основная проблема реализации данного способа - список может быть длинным. Чтобы разрешить всем пользователям читать файл, необходимо всех их внести в список. У такой техники есть два нежелательных следствия.
</p><ul>
<li> Конструирование подобного списка может оказаться сложной задачей, особенно если мы не знаем заранее пользователей системы.
<li> Запись в директории должна иметь переменный размер (включать список потенциальных пользователей).
</ul>
<p>Для решения этих проблем создают классификации пользователей, например, в ОС Unix все пользователи разделены на три группы.
</p><ol>
<li> <b>Владелец</b> (Owner).
<li> <b>Группа</b> (Group). Hабор пользователей, разделяющих файл и нуждающихся в типовом способе доступа к нему.
<li> <b>Остальные</b> (Univers).
</ol>
<p>Это позволяет реализовать конденсированную версию списка прав доступа. В рамках такой ограниченной классификации задаются только три поля (по одному для каждой группы) для каждой контролируемой операции. В итоге в Unix операции чтения, записи и исполнения контролируются при помощи 9 бит <b>(rwxrwxrwx)</b>.
</p><a name="1-12-Вопросы для самопроверки"></a>


<h2>Вопросы для самоконтроля</h2>

<ol>
</ol>
<p align='right'><b>© 2012 Штанюк А.А.</b></p>
</div>
<div class="right">
<h2>Разделы :</h2>

<ul>
<li><a href="#1-1-Понятие файловой системы">Понятие файловой системы</a></li><li><a href="#1-2-Общие сведения о файлах">Общие сведения о файлах</a></li>
<ul>
<li><a href="#2-3-Имена файлов">Имена файлов</a></li><li><a href="#2-4-Типы файлов">Типы файлов</a></li><li><a href="#2-5-Атрибуты файлов">Атрибуты файлов</a></li><li><a href="#2-6-Операции над файлами">Операции над файлами</a></li>
</ul>
<li><a href="#1-7-Директории(папки)">Директории(папки)</a></li>
<ul>
<li><a href="#2-8-Общие сведения о директориях">Общие сведения о директориях</a></li><li><a href="#2-9-Разделы и имена файлов">Разделы и имена файлов</a></li><li><a href="#2-10-Операции над директориями">Операции над директориями</a></li>
</ul>
<li><a href="#1-11-Защита файлов и директорий">Защита файлов и директорий</a></li><li><a href="#1-12-Вопросы для самопроверки">Вопросы для самопроверки</a></li></ul></div>
<div style="clear: both;"> </div>

</div>

<div id="footer">
</div>

</div>

</body>
</html>

